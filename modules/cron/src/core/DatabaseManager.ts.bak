import { prisma } from '../../../shared/src/prismaClient.js';

function toDateTime(v: any): Date | null {
  if (v == null) return null;
  if (v instanceof Date) return v;
  if (typeof v === "string") {
    if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return new Date(`${v}T00:00:00.000Z`);
    return new Date(v);
  }
  return new Date(v);
}

function normalizeFinalReportDates<T extends { reportDate?: any; snapshotDate?: any }>(o: T): T {
  return {
    ...o,
    reportDate: toDateTime(o.reportDate),
    snapshotDate: toDateTime(o.snapshotDate),
  };
}

function toDateTime(v: any): Date | null {
  if (v == null) return null;
  if (v instanceof Date) return v;
  if (typeof v === "string") {
    // ak je to len YYYY-MM-DD, dopl≈à ƒças
    if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return new Date(`${v}T00:00:00.000Z`);
    // inak ver√≠me, ≈æe je to ISO
    return new Date(v);
  }
  return new Date(v);
}

function normalizeFinalReportDates<T extends { reportDate?: any; snapshotDate?: any }>(o: T): T {
  return {
    ...o,
    reportDate: toDateTime(o.reportDate),
    snapshotDate: toDateTime(o.snapshotDate),
  };
}

import { CreateFinhubData, CreatePolygonData, CreateFinalReport } from '../../../shared/src/types.js';

function toDateTime(v: any): Date | null {
  if (v == null) return null;
  if (v instanceof Date) return v;
  if (typeof v === "string") {
    if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return new Date(`${v}T00:00:00.000Z`);
    return new Date(v);
  }
  return new Date(v);
}

function normalizeFinalReportDates<T extends { reportDate?: any; snapshotDate?: any }>(o: T): T {
  return {
    ...o,
    reportDate: toDateTime(o.reportDate),
    snapshotDate: toDateTime(o.snapshotDate),
  };
}

function toDateTime(v: any): Date | null {
  if (v == null) return null;
  if (v instanceof Date) return v;
  if (typeof v === "string") {
    // ak je to len YYYY-MM-DD, dopl≈à ƒças
    if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return new Date(`${v}T00:00:00.000Z`);
    // inak ver√≠me, ≈æe je to ISO
    return new Date(v);
  }
  return new Date(v);
}

function normalizeFinalReportDates<T extends { reportDate?: any; snapshotDate?: any }>(o: T): T {
  return {
    ...o,
    reportDate: toDateTime(o.reportDate),
    snapshotDate: toDateTime(o.snapshotDate),
  };
}

import { Prisma } from '@prisma/client';

function toDateTime(v: any): Date | null {
  if (v == null) return null;
  if (v instanceof Date) return v;
  if (typeof v === "string") {
    if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return new Date(`${v}T00:00:00.000Z`);
    return new Date(v);
  }
  return new Date(v);
}

function normalizeFinalReportDates<T extends { reportDate?: any; snapshotDate?: any }>(o: T): T {
  return {
    ...o,
    reportDate: toDateTime(o.reportDate),
    snapshotDate: toDateTime(o.snapshotDate),
  };
}

function toDateTime(v: any): Date | null {
  if (v == null) return null;
  if (v instanceof Date) return v;
  if (typeof v === "string") {
    // ak je to len YYYY-MM-DD, dopl≈à ƒças
    if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return new Date(`${v}T00:00:00.000Z`);
    // inak ver√≠me, ≈æe je to ISO
    return new Date(v);
  }
  return new Date(v);
}

function normalizeFinalReportDates<T extends { reportDate?: any; snapshotDate?: any }>(o: T): T {
  return {
    ...o,
    reportDate: toDateTime(o.reportDate),
    snapshotDate: toDateTime(o.snapshotDate),
  };
}

import Decimal from 'decimal.js';

function toDateTime(v: any): Date | null {
  if (v == null) return null;
  if (v instanceof Date) return v;
  if (typeof v === "string") {
    if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return new Date(`${v}T00:00:00.000Z`);
    return new Date(v);
  }
  return new Date(v);
}

function normalizeFinalReportDates<T extends { reportDate?: any; snapshotDate?: any }>(o: T): T {
  return {
    ...o,
    reportDate: toDateTime(o.reportDate),
    snapshotDate: toDateTime(o.snapshotDate),
  };
}

   * Calculates marketCapDiff from previousMarketCap and change percentage:
   * - marketCapDiff = previousMarketCap * (change / 100)
   * - currentMarketCap = previousMarketCap + marketCapDiff
   * 
   * @param incoming - Data object containing symbol and optional fields
   * @returns Promise<void>
   */
  async upsertFinalReport(incoming: {
    symbol: string;
    name?: string | null;
    size?: string | null;
    previousMarketCap?: number | null;
    change?: number | null;
    price?: number | null;
    epsActual?: number | null;
    epsEst?: number | null;
    epsSurp?: number | null;
    revActual?: number | null;
    revEst?: number | null;
    revSurp?: number | null;
  }): Promise<void> {
    const prevMC = incoming.previousMarketCap ?? null;
    const changePct = incoming.change ?? null;

    let marketCapDiff: bigint | null = null;
    let currentMarketCap: bigint | null = null;
    if (prevMC != null && Number.isFinite(changePct)) {
      const diffDec = new Decimal(prevMC).times(new Decimal(changePct as number).div(100));
      const currDec = new Decimal(prevMC).plus(diffDec);
      marketCapDiff = BigInt(diffDec.toFixed(0));
      currentMarketCap = BigInt(currDec.toFixed(0));
    }

const createData = normalizeFinalReportDates({
  symbol,
  name,
  size,
  marketCap,
  marketCapDiff,
  price,
  change,
  epsActual,
  epsEst,
  epsSurp,
  revActual,
  revEst,
  revSurp,
  reportDate,
  snapshotDate,
  logoUrl,
  logoSource,
  logoFetchedAt,
});

const updateData = normalizeFinalReportDates({
  name,
  size,
  marketCap,
  marketCapDiff,
  price,
  change,
  epsActual,
  epsEst,
  epsSurp,
  revActual,
  revEst,
  revSurp,
  reportDate,
  snapshotDate,
  logoUrl,
  logoSource,
  logoFetchedAt,
});

const createData = normalizeFinalReportDates({
  symbol,
  name,
  size,
  marketCap,
  marketCapDiff,
  price,
  change,
  epsActual,
  epsEst,
  epsSurp,
  revActual,
  revEst,
  revSurp,
  reportDate,
  snapshotDate,
  logoUrl,
  logoSource,
  logoFetchedAt,
});

const updateData = normalizeFinalReportDates({
  name,
  size,
  marketCap,
  marketCapDiff,
  price,
  change,
  epsActual,
  epsEst,
  epsSurp,
  revActual,
  revEst,
  revSurp,
  reportDate,
  snapshotDate,
  logoUrl,
  logoSource,
  logoFetchedAt,
});

await prisma.finalReport.upsert({
  where: { symbol },
  create: createData,
  update: updateData,
});
  }
  // FinhubData operations
  async upsertFinhubData(data: CreateFinhubData[]): Promise<void> {
    console.log(`‚Üí Upserting ${data.length} finhub reports in batch transaction...`);
    
    if (data.length === 0) {
      console.log('‚úì No data to upsert');
      return;
    }

    // Batch operations for better performance
    const batchSize = 100;

    // Execute batches sequentially to avoid overwhelming the database
    let totalUpserted = 0;
    for (let i = 0; i < data.length; i += batchSize) {
      const batch = data.slice(i, i + batchSize);
      console.log(`‚Üí Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(data.length / batchSize)} (${batch.length} records)...`);
      await prisma.$transaction(
        batch.map(record =>
          prisma.finhubData.upsert({
            where: {
              reportDate_symbol: {
                reportDate: record.reportDate,
                symbol: record.symbol,
              },
            },
            update: {
              hour: record.hour ?? null,
              epsActual: record.epsActual ?? null,
              epsEstimate: record.epsEstimate ?? null,
              revenueActual: record.revenueActual ? BigInt(Math.round(record.revenueActual)) : null,
              revenueEstimate: record.revenueEstimate ? BigInt(Math.round(record.revenueEstimate)) : null,
              quarter: record.quarter ?? null,
              year: record.year ?? null,
            },
            create: {
              reportDate: record.reportDate,
              symbol: record.symbol,
              hour: record.hour ?? null,
              epsActual: record.epsActual ?? null,
              epsEstimate: record.epsEstimate ?? null,
              revenueActual: record.revenueActual ? BigInt(Math.round(record.revenueActual)) : null,
              revenueEstimate: record.revenueEstimate ? BigInt(Math.round(record.revenueEstimate)) : null,
              quarter: record.quarter ?? null,
              year: record.year ?? null,
            },
          })
        )
      );
      totalUpserted += batch.length;
    }
    
    console.log(`‚úì Successfully upserted ${totalUpserted} finhub reports in ${Math.ceil(data.length / batchSize)} batches`);
  }

  async getFinhubDataByDate(date: Date) {
    const y = date.getUTCFullYear();
    const m = date.getUTCMonth();
    const d = date.getUTCDate();
    const start = new Date(Date.UTC(y, m, d, 0, 0, 0));
    const end = new Date(Date.UTC(y, m, d + 1, 0, 0, 0));

    return await prisma.finhubData.findMany({
      where: {
        reportDate: {
          gte: start,
          lt: end,
        }
      },
      orderBy: {
        symbol: 'asc'
      }
    });
  }

      async clearFinhubData(): Promise<void> {
        console.log('üóëÔ∏è Clearing FinhubData...');
        const result = await prisma.finhubData.deleteMany();
        console.log(`‚úÖ Cleared ${result.count} FinhubData records`);
      }

      // PolygonData operations
      async upsertPolygonData(data: CreatePolygonData[]): Promise<void> {
        console.log(`‚Üí Upserting ${data.length} polygon symbols (batched)...`);
        if (data.length === 0) return;

        const batchSize = 100;
        let total = 0;
        for (let i = 0; i < data.length; i += batchSize) {
          const batch = data.slice(i, i + batchSize);
          await prisma.$transaction(
            batch.map(record =>
              prisma.polygonData.upsert({
                where: { symbol: record.symbol },
                update: {
                  symbolBoolean: record.symbolBoolean ?? false,
                  marketCap: record.marketCap ?? null,
                  previousMarketCap: record.previousMarketCap ?? null,
                  marketCapDiff: record.marketCapDiff ?? null,
                  marketCapBoolean: record.marketCapBoolean ?? false,
                  price: record.price ?? null,
                  previousCloseRaw: record.previousCloseRaw ?? null,
                  previousCloseAdj: record.previousCloseAdj ?? null,
                  previousCloseSource: record.previousCloseSource ?? null,
                  changeFromPrevClosePct: record.changeFromPrevClosePct ?? null,
                  changeFromOpenPct: record.changeFromOpenPct ?? null,
                  sessionRef: record.sessionRef ?? null,
                  qualityFlags: record.qualityFlags as any,
                  change: record.change ?? null,
                  size: record.size ?? null,
                  name: record.name ?? null,
                  priceBoolean: record.priceBoolean ?? false,
                  Boolean: record.Boolean ?? false,
                  priceSource: record.priceSource ?? null,
                },
                create: {
                  symbol: record.symbol,
                  symbolBoolean: record.symbolBoolean ?? false,
                  marketCap: record.marketCap ?? null,
                  previousMarketCap: record.previousMarketCap ?? null,
                  marketCapDiff: record.marketCapDiff ?? null,
                  marketCapBoolean: record.marketCapBoolean ?? false,
                  price: record.price ?? null,
                  previousCloseRaw: record.previousCloseRaw ?? null,
                  previousCloseAdj: record.previousCloseAdj ?? null,
                  previousCloseSource: record.previousCloseSource ?? null,
                  changeFromPrevClosePct: record.changeFromPrevClosePct ?? null,
                  changeFromOpenPct: record.changeFromOpenPct ?? null,
                  sessionRef: record.sessionRef ?? null,
                  qualityFlags: record.qualityFlags as any,
                  change: record.change ?? null,
                  size: record.size ?? null,
                  name: record.name ?? null,
                  priceBoolean: record.priceBoolean ?? false,
                  Boolean: record.Boolean ?? false,
                  priceSource: record.priceSource ?? null,
                },
              })
            )
          );
          total += batch.length;
        }
        console.log(`‚úì Successfully upserted ${total} polygon symbols`);
      }

      async copySymbolsToPolygonData(): Promise<void> {
        console.log('üîÑ Copying symbols from FinhubData to PolygonData...');
        
        const symbols = await prisma.finhubData.findMany({
          select: { symbol: true },
          distinct: ['symbol'],
          where: { symbol: { not: '' } }
        });
        
        // Use upsert for each symbol to handle duplicates
        for (const symbol of symbols) {
          await prisma.polygonData.upsert({
            where: { symbol: symbol.symbol },
            create: { 
              symbol: symbol.symbol,
              symbolBoolean: true
            },
            update: {
              symbolBoolean: true
            }
          });
        }
        
        console.log(`‚úì PolygonData: inserted ${symbols.length} (deduped) symbols`);
      }

      async getUniqueSymbolsFromPolygonData(onlyReady = false): Promise<string[]> {
        const symbols = await prisma.polygonData.findMany({
          select: { symbol: true },
          ...(onlyReady ? { where: { Boolean: true } } : {}),
        });
        return symbols.map(s => s.symbol);
      }

      async getPolygonSymbols(onlyReady = false): Promise<string[]> {
        return this.getUniqueSymbolsFromPolygonData(onlyReady);
      }

      async updatePolygonMarketCapData(marketData: any[]): Promise<void> {
        console.log(`‚Üí Upserting market cap data for ${marketData.length} symbols in batches...`);
        
        // Process in batches of 100 for better performance
        const batchSize = 100;
        let totalUpserted = 0;
        
        for (let i = 0; i < marketData.length; i += batchSize) {
          const batch = marketData.slice(i, i + batchSize);
          console.log(`‚Üí Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(marketData.length / batchSize)} (${batch.length} records)...`);
          
          await prisma.$transaction(
            batch.map(data =>
              prisma.polygonData.upsert({
                where: {
                  symbol: data.symbol,
                },
                create: {
                  symbol: data.symbol,
                  symbolBoolean: Boolean(data.symbolBoolean ?? 0), // Convert to boolean
                  marketCap: data.marketCap,
                  previousMarketCap: data.previousMarketCap,
                  marketCapDiff: data.marketCapDiff,
                  marketCapBoolean: Boolean(data.marketCapBoolean ?? 0), // Convert to boolean
                  price: data.price,
                  previousCloseRaw: data.previousCloseRaw,
                  previousCloseAdj: data.previousCloseAdj,
                  previousCloseSource: data.previousCloseSource,
                  changeFromPrevClosePct: data.changeFromPrevClosePct,
                  changeFromOpenPct: data.changeFromOpenPct,
                  sessionRef: data.sessionRef,
                  qualityFlags: data.qualityFlags,
                  change: data.change,
                  size: data.size,
                  name: data.name,
                  priceBoolean: Boolean(data.priceBoolean ?? 0), // Convert to boolean
                  Boolean: Boolean(data.Boolean ?? 0), // Convert to boolean
                  priceSource: data.priceSource,
                  // Logo fields - only set if provided
                  ...(data.logoUrl !== undefined && { logoUrl: data.logoUrl }),
                  ...(data.logoSource !== undefined && { logoSource: data.logoSource }),
                  ...(data.logoFetchedAt !== undefined && { logoFetchedAt: data.logoFetchedAt }),
                },
                update: {
                  symbolBoolean: Boolean(data.symbolBoolean ?? 0), // Convert to boolean
                  marketCap: data.marketCap,
                  previousMarketCap: data.previousMarketCap,
                  marketCapDiff: data.marketCapDiff,
                  marketCapBoolean: Boolean(data.marketCapBoolean ?? 0), // Convert to boolean
                  price: data.price,
                  previousCloseRaw: data.previousCloseRaw,
                  previousCloseAdj: data.previousCloseAdj,
                  previousCloseSource: data.previousCloseSource,
                  changeFromPrevClosePct: data.changeFromPrevClosePct,
                  changeFromOpenPct: data.changeFromOpenPct,
                  sessionRef: data.sessionRef,
                  qualityFlags: data.qualityFlags,
                  change: data.change,
                  size: data.size,
                  name: data.name,
                  priceBoolean: Boolean(data.priceBoolean ?? 0), // Convert to boolean
                  Boolean: Boolean(data.Boolean ?? 0), // Convert to boolean
                  priceSource: data.priceSource,
                  // Logo fields - only update if provided (preserve existing)
                  ...(data.logoUrl !== undefined && { logoUrl: data.logoUrl }),
                  ...(data.logoSource !== undefined && { logoSource: data.logoSource }),
                  ...(data.logoFetchedAt !== undefined && { logoFetchedAt: data.logoFetchedAt }),
                },
              })
            )
          );
          
          totalUpserted += batch.length;
        }
        
        console.log(`‚úì Successfully upserted market cap data for ${totalUpserted} symbols in ${Math.ceil(marketData.length / batchSize)} batches`);
      }

      async clearPolygonData(): Promise<void> {
        console.log('üóëÔ∏è Clearing PolygonData...');
        const result = await prisma.polygonData.deleteMany();
        console.log(`‚úÖ Cleared ${result.count} PolygonData records`);
      }

      // FinalReport operations
      async generateFinalReport(): Promise<void> {
        console.log('üîÑ Generating FinalReport from FinhubData and PolygonData...');
        
        // Clear existing FinalReport to ensure only valid symbols are included
        
        // Get all symbols that exist in both tables
        const finhubSymbols = await prisma.finhubData.findMany({
          select: { symbol: true },
          distinct: ['symbol'],
        });
        
        // Get only symbols from PolygonData where Boolean = true (all conditions met)
        const polygonSymbols = await prisma.polygonData.findMany({
          select: { symbol: true },
          where: { 
            Boolean: true
          },
        });
        
        const finhubSymbolSet = new Set(finhubSymbols.map(s => s.symbol));
        const polygonSymbolSet = new Set(polygonSymbols.map(s => s.symbol));
        
        // Find symbols that exist in both tables AND have Boolean = true in PolygonData
        const commonSymbols = Array.from(finhubSymbolSet).filter(symbol => polygonSymbolSet.has(symbol));
        
        console.log(`üìä Found ${commonSymbols.length} symbols in both FinhubData and PolygonData with Boolean = true (all conditions met)`);
        const todayNY = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
        
        for (const symbol of commonSymbols) {
          // Get data from FinhubData
          const finhubData = await prisma.finhubData.findFirst({
            where: { symbol },
            orderBy: { reportDate: 'desc' }, // Get the most recent data
          });
          
          // Get data from PolygonData
          const polygonData = await prisma.polygonData.findUnique({
            where: { symbol },
          });
          
          if (finhubData && polygonData) {
            // Calculate percentage differences using correct formula: ((actual - estimate) / |estimate|) * 100
            const epsSurp = (finhubData.epsActual != null && finhubData.epsEstimate != null && finhubData.epsEstimate !== 0)
              ? ((finhubData.epsActual - finhubData.epsEstimate) / Math.abs(finhubData.epsEstimate)) * 100
              : null;
            
            const revSurp = (finhubData.revenueActual != null && finhubData.revenueEstimate != null && finhubData.revenueEstimate !== 0n)
              ? new Decimal(finhubData.revenueActual.toString()).minus(finhubData.revenueEstimate.toString()).div(new Decimal(finhubData.revenueEstimate.toString()).abs()).times(100).toNumber()
              : null;
            
            // Round decimal values to max 2 decimal places
            // Use previousClose as fallback for weekends when current price is not available
            const priceToUse = polygonData.price ?? polygonData.previousCloseRaw;
            const roundedPrice = priceToUse ? Math.round(priceToUse * 100) / 100 : null;
            const roundedChange = polygonData.change !== null && polygonData.change !== undefined ? Math.round(polygonData.change * 100) / 100 : null;
            const roundedEpsActual = finhubData.epsActual ? Math.round(finhubData.epsActual * 100) / 100 : null;
            const roundedEpsEst = finhubData.epsEstimate ? Math.round(finhubData.epsEstimate * 100) / 100 : null;
            const roundedEpsSurp = epsSurp ? Math.round(epsSurp * 100) / 100 : null;
            const roundedRevSurp = revSurp ? Math.round(revSurp * 100) / 100 : null;
            
            // Use direct upsert since marketCap and marketCapDiff are already calculated in PolygonData
const createData = normalizeFinalReportDates({
  symbol,
  name,
  size,
  marketCap,
  marketCapDiff,
  price,
  change,
  epsActual,
  epsEst,
  epsSurp,
  revActual,
  revEst,
  revSurp,
  reportDate,
  snapshotDate,
  logoUrl,
  logoSource,
  logoFetchedAt,
});

const updateData = normalizeFinalReportDates({
  name,
  size,
  marketCap,
  marketCapDiff,
  price,
  change,
  epsActual,
  epsEst,
  epsSurp,
  revActual,
  revEst,
  revSurp,
  reportDate,
  snapshotDate,
  logoUrl,
  logoSource,
  logoFetchedAt,
});

const createData = normalizeFinalReportDates({
  symbol,
  name,
  size,
  marketCap,
  marketCapDiff,
  price,
  change,
  epsActual,
  epsEst,
  epsSurp,
  revActual,
  revEst,
  revSurp,
  reportDate,
  snapshotDate,
  logoUrl,
  logoSource,
  logoFetchedAt,
});

const updateData = normalizeFinalReportDates({
  name,
  size,
  marketCap,
  marketCapDiff,
  price,
  change,
  epsActual,
  epsEst,
  epsSurp,
  revActual,
  revEst,
  revSurp,
  reportDate,
  snapshotDate,
  logoUrl,
  logoSource,
  logoFetchedAt,
});

await prisma.finalReport.upsert({
  where: { symbol },
  create: createData,
  update: updateData,
});
          }
        }
        
        // ‚úÖ Log a≈æ po re√°lnom ulo≈æen√≠:
        console.log(`‚úÖ FinalReport snapshot stored: ${commonSymbols.length} symbols`);
      }
      async getFinalReport(): Promise<any[]> {
        return await prisma.finalReport.findMany({
          orderBy: { symbol: 'asc' },
        });
      }

      async clearFinalReport(): Promise<void> {
        console.log('üóëÔ∏è Clearing FinalReport...');
        const result = await prisma.finalReport.deleteMany();
        console.log(`‚úÖ Cleared ${result.count} FinalReport records`);
      }

  /**
   * Update logo information for a symbol
   */
      async updateLogoInfo(symbol: string, logoUrl: string | null, logoSource: string | null): Promise<void> {
        // Update all records for this symbol (there might be multiple report dates)
        await prisma.finhubData.updateMany({
          where: { symbol },
          data: {
            logoUrl,
            logoSource,
            logoFetchedAt: new Date(),
          },
        });
        console.log(`   ‚Üí Updated logo info for ${symbol}: ${logoUrl} (${logoSource})`);
      }

  /**
   * Get symbols that need logo refresh
   */
  async getSymbolsNeedingLogoRefresh(): Promise<string[]> {
    const symbols = await prisma.finhubData.findMany({
      where: {
        OR: [
          { logoUrl: null },
          { logoFetchedAt: null },
          {
            logoFetchedAt: {
              lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // 30 days ago
            },
          },
        ],
      },
      select: { symbol: true },
      distinct: ['symbol'],
    });

    return symbols.map(s => s.symbol);
  }

  /**
   * Update cron job status
   */
  async updateCronStatus(jobType: string, status: 'success' | 'error' | 'running', recordsProcessed?: number, errorMessage?: string): Promise<void> {
    await prisma.cronStatus.upsert({
      where: { jobType },
      create: {
        jobType,
        lastRunAt: new Date(),
        status,
        recordsProcessed,
        errorMessage,
      },
      update: {
        lastRunAt: new Date(),
        status,
        recordsProcessed,
        errorMessage,
      },
    });
  }

  /**
   * Get last cron run timestamp
   */
  async getLastCronRun(jobType: string): Promise<Date | null> {
    const status = await prisma.cronStatus.findUnique({
      where: { jobType },
      select: { lastRunAt: true },
    });
    return status?.lastRunAt || null;
  }

  /**
   * Get all cron statuses
   */
  async getAllCronStatuses(): Promise<any[]> {
    return await prisma.cronStatus.findMany({
      orderBy: { lastRunAt: 'desc' },
    });
  }

  async clearAllTables(): Promise<void> {
    console.log('üõë Clearing all database tables...');
    
    // Clear tables in correct order (respecting foreign key constraints)
    await prisma.finalReport.deleteMany();
    await prisma.polygonData.deleteMany();
    await prisma.finhubData.deleteMany();
    await prisma.cronStatus.deleteMany();
    
    console.log('‚úÖ All tables cleared successfully');
  }

  async disconnect(): Promise<void> {
    await prisma.$disconnect();
  }
}

// Singleton instance
export const db = new DatabaseManager();