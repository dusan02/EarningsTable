import { prisma } from '../../../shared/src/prismaClient.js';
import { CreateFinhubData, CreatePolygonData, CreateFinalReport } from '../../../shared/src/types.js';
import { Prisma } from '@prisma/client';
import Decimal from 'decimal.js';

function toDateTime(v: any): Date | null {
  if (v == null) return null;
  if (v instanceof Date) return v;
  if (typeof v === "string") {
    if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return new Date(`${v}T00:00:00.000Z`);
    return new Date(v);
  }
  return new Date(v);
}

function normalizeFinalReportDates<T extends { reportDate?: any; snapshotDate?: any }>(o: T): T {
  return {
    ...o,
    reportDate: toDateTime(o.reportDate),
    snapshotDate: toDateTime(o.snapshotDate),
  };
}

export class DatabaseManager {
  /**
   * Calculates marketCapDiff from previousMarketCap and change percentage: 
   * - marketCapDiff = previousMarketCap * (change / 100)
   * - currentMarketCap = previousMarketCap + marketCapDiff
   *
   * @param incoming - Data object containing symbol and optional fields    
   * @returns Promise<void>
   */
  async upsertFinalReport(incoming: {
    symbol: string;
    name?: string | null;
    size?: string | null;
    previousMarketCap?: number | null;
    change?: number | null;
    price?: number | null;
    epsActual?: number | null;
    epsEst?: number | null;
    epsSurp?: number | null;
    revActual?: number | null;
    revEst?: number | null;
    revSurp?: number | null;
  }): Promise<void> {
    const prevMC = incoming.previousMarketCap ?? null;
    const changePct = incoming.change ?? null;

    let marketCapDiff: bigint | null = null;
    let currentMarketCap: bigint | null = null;
    if (prevMC != null && Number.isFinite(changePct)) {
      const diffDec = new Decimal(prevMC.toString()).mul(new Decimal(changePct as number).div(100));
      const currDec = new Decimal(prevMC.toString()).add(diffDec);
      marketCapDiff = BigInt(diffDec.toDecimalPlaces(0, Decimal.ROUND_HALF_UP).toString());
      currentMarketCap = BigInt(currDec.toDecimalPlaces(0, Decimal.ROUND_HALF_UP).toString());
    }

    const createData = normalizeFinalReportDates({
      symbol: incoming.symbol,
      name: incoming.name,
      size: incoming.size,
      marketCap: currentMarketCap,
      marketCapDiff,
      price: incoming.price,
      change: incoming.change,
      epsActual: incoming.epsActual,
      epsEst: incoming.epsEst,
      epsSurp: incoming.epsSurp,
      revActual: incoming.revActual,
      revEst: incoming.revEst,
      revSurp: incoming.revSurp,
      reportDate: new Date(),
      snapshotDate: new Date(),
    });

    const updateData = normalizeFinalReportDates({
      name: incoming.name,
      size: incoming.size,
      marketCap: currentMarketCap,
      marketCapDiff,
      price: incoming.price,
      change: incoming.change,
      epsActual: incoming.epsActual,
      epsEst: incoming.epsEst,
      epsSurp: incoming.epsSurp,
      revActual: incoming.revActual,
      revEst: incoming.revEst,
      revSurp: incoming.revSurp,
      reportDate: new Date(),
      snapshotDate: new Date(),
    });

    await prisma.finalReport.upsert({
      where: { symbol: incoming.symbol },
      create: createData,
      update: updateData,
    });
  }

  // FinhubData operations
  async upsertFinhubData(data: CreateFinhubData[]): Promise<void> {
    console.log(`‚Üí Upserting ${data.length} finhub reports in batch transaction...`);

    if (data.length === 0) {
      console.log('‚úì No data to upsert');
      return;
    }

    const batchSize = 100;
    let totalUpserted = 0;
    for (let i = 0; i < data.length; i += batchSize) {
      const batch = data.slice(i, i + batchSize);
      console.log(`‚Üí Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(data.length / batchSize)} (${batch.length} records)...`);
      await prisma.$transaction(
        batch.map(record =>
          prisma.finhubData.upsert({
            where: {
              reportDate_symbol: {
                reportDate: record.reportDate,
                symbol: record.symbol,
              },
            },
            update: {
              hour: record.hour ?? null,
              epsActual: record.epsActual ?? null,
              epsEstimate: record.epsEstimate ?? null,
              revenueActual: record.revenueActual ? BigInt(Math.round(record.revenueActual)) : null,
              revenueEstimate: record.revenueEstimate ? BigInt(Math.round(record.revenueEstimate)) : null,
              quarter: record.quarter ?? null,
              year: record.year ?? null,
            },
            create: {
              reportDate: record.reportDate,
              symbol: record.symbol,
              hour: record.hour ?? null,
              epsActual: record.epsActual ?? null,
              epsEstimate: record.epsEstimate ?? null,
              revenueActual: record.revenueActual ? BigInt(Math.round(record.revenueActual)) : null,
              revenueEstimate: record.revenueEstimate ? BigInt(Math.round(record.revenueEstimate)) : null,
              quarter: record.quarter ?? null,
              year: record.year ?? null,
            },
          })
        )
      );
      totalUpserted += batch.length;
    }

    console.log(`‚úì Successfully upserted ${totalUpserted} finhub reports in ${Math.ceil(data.length / batchSize)} batches`);
  }

  async getFinhubDataByDate(date: Date) {
    const y = date.getUTCFullYear();
    const m = date.getUTCMonth();
    const d = date.getUTCDate();
    const start = new Date(Date.UTC(y, m, d, 0, 0, 0));
    const end = new Date(Date.UTC(y, m, d + 1, 0, 0, 0));

    return await prisma.finhubData.findMany({
      where: {
        reportDate: {
          gte: start,
          lt: end,
        }
      },
      orderBy: {
        symbol: 'asc'
      }
    });
  }

  async clearFinhubData(): Promise<void> {
    console.log('üóëÔ∏è Clearing FinhubData...');
    const result = await prisma.finhubData.deleteMany();
    console.log(`‚úÖ Cleared ${result.count} FinhubData records`);
  }

  // PolygonData operations
  async upsertPolygonData(data: CreatePolygonData[]): Promise<void> {       
    console.log(`‚Üí Upserting ${data.length} polygon symbols (batched)...`); 
    if (data.length === 0) return;

    const batchSize = 100;
    let total = 0;
    for (let i = 0; i < data.length; i += batchSize) {
      const batch = data.slice(i, i + batchSize);
      await prisma.$transaction(
        batch.map(record =>
          prisma.polygonData.upsert({
            where: { symbol: record.symbol },
            update: {
              symbolBoolean: record.symbolBoolean ?? false,
              marketCap: record.marketCap ?? null,
              previousMarketCap: record.previousMarketCap ?? null,
              marketCapDiff: record.marketCapDiff ?? null,
              marketCapBoolean: record.marketCapBoolean ?? false,
              price: record.price ?? null,
              previousCloseRaw: record.previousCloseRaw ?? null,
              previousCloseAdj: record.previousCloseAdj ?? null,
              previousCloseSource: record.previousCloseSource ?? null,      
              changeFromPrevClosePct: record.changeFromPrevClosePct ?? null,
              changeFromOpenPct: record.changeFromOpenPct ?? null,
              sessionRef: record.sessionRef ?? null,
              qualityFlags: record.qualityFlags as any,
              change: record.change ?? null,
              size: record.size ?? null,
              name: record.name ?? null,
              priceBoolean: record.priceBoolean ?? false,
              Boolean: record.Boolean ?? false,
              priceSource: record.priceSource ?? null,
            },
            create: {
              symbol: record.symbol,
              symbolBoolean: record.symbolBoolean ?? false,
              marketCap: record.marketCap ?? null,
              previousMarketCap: record.previousMarketCap ?? null,
              marketCapDiff: record.marketCapDiff ?? null,
              marketCapBoolean: record.marketCapBoolean ?? false,
              price: record.price ?? null,
              previousCloseRaw: record.previousCloseRaw ?? null,
              previousCloseAdj: record.previousCloseAdj ?? null,
              previousCloseSource: record.previousCloseSource ?? null,      
              changeFromPrevClosePct: record.changeFromPrevClosePct ?? null,
              changeFromOpenPct: record.changeFromOpenPct ?? null,
              sessionRef: record.sessionRef ?? null,
              qualityFlags: record.qualityFlags as any,
              change: record.change ?? null,
              size: record.size ?? null,
              name: record.name ?? null,
              priceBoolean: record.priceBoolean ?? false,
              Boolean: record.Boolean ?? false,
              priceSource: record.priceSource ?? null,
            },
          })
        )
      );
      total += batch.length;
    }
    console.log(`‚úì Successfully upserted ${total} polygon symbols`);        
  }

  async copySymbolsToPolygonData(): Promise<void> {
    console.log('üîÑ Copying symbols from FinhubData to PolygonData...');    

    const symbols = await prisma.finhubData.findMany({
      select: { symbol: true },
      distinct: ['symbol'],
      where: { symbol: { not: '' } }
    });

    for (const symbol of symbols) {
      await prisma.polygonData.upsert({
        where: { symbol: symbol.symbol },
        create: {
          symbol: symbol.symbol,
          symbolBoolean: true
        },
        update: {
          symbolBoolean: true
        }
      });
    }

    console.log(`‚úì PolygonData: inserted ${symbols.length} (deduped) symbols`);
  }

  async getUniqueSymbolsFromPolygonData(onlyReady = false): Promise<string[]> {
    const symbols = await prisma.polygonData.findMany({
      select: { symbol: true },
      ...(onlyReady ? { where: { Boolean: true } } : {}),
    });
    return symbols.map(s => s.symbol);
  }

  async getPolygonSymbols(onlyReady = false): Promise<string[]> {
    return this.getUniqueSymbolsFromPolygonData(onlyReady);
  }

  async updatePolygonMarketCapData(marketData: any[]): Promise<void> {      
    console.log(`‚Üí Upserting market cap data for ${marketData.length} symbols in batches...`);

    const batchSize = 100;
    let totalUpserted = 0;

    for (let i = 0; i < marketData.length; i += batchSize) {
      const batch = marketData.slice(i, i + batchSize);
      console.log(`‚Üí Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(marketData.length / batchSize)} (${batch.length} records)...`);      

      await prisma.$transaction(
        batch.map(data =>
          prisma.polygonData.upsert({
            where: {
              symbol: data.symbol,
            },
            create: {
              symbol: data.symbol,
              symbolBoolean: Boolean(data.symbolBoolean ?? 0),
              marketCap: data.marketCap,
              previousMarketCap: data.previousMarketCap,
              marketCapDiff: data.marketCapDiff,
              marketCapBoolean: Boolean(data.marketCapBoolean ?? 0),
              price: data.price,
              previousCloseRaw: data.previousCloseRaw,
              previousCloseAdj: data.previousCloseAdj,
              previousCloseSource: data.previousCloseSource,
              changeFromPrevClosePct: data.changeFromPrevClosePct,
              changeFromOpenPct: data.changeFromOpenPct,
              sessionRef: data.sessionRef,
              qualityFlags: data.qualityFlags,
              change: data.change,
              size: data.size,
              name: data.name,
              priceBoolean: Boolean(data.priceBoolean ?? 0),
              Boolean: Boolean(data.Boolean ?? 0),
              priceSource: data.priceSource,
              ...(data.logoUrl !== undefined && { logoUrl: data.logoUrl }), 
              ...(data.logoSource !== undefined && { logoSource: data.logoSource }),
              ...(data.logoFetchedAt !== undefined && { logoFetchedAt: data.logoFetchedAt }),
            },
            update: {
              symbolBoolean: Boolean(data.symbolBoolean ?? 0),
              marketCap: data.marketCap,
              previousMarketCap: data.previousMarketCap,
              marketCapDiff: data.marketCapDiff,
              marketCapBoolean: Boolean(data.marketCapBoolean ?? 0),
              price: data.price,
              previousCloseRaw: data.previousCloseRaw,
              previousCloseAdj: data.previousCloseAdj,
              previousCloseSource: data.previousCloseSource,
              changeFromPrevClosePct: data.changeFromPrevClosePct,
              changeFromOpenPct: data.changeFromOpenPct,
              sessionRef: data.sessionRef,
              qualityFlags: data.qualityFlags,
              change: data.change,
              size: data.size,
              name: data.name,
              priceBoolean: Boolean(data.priceBoolean ?? 0),
              Boolean: Boolean(data.Boolean ?? 0),
              priceSource: data.priceSource,
              ...(data.logoUrl !== undefined && { logoUrl: data.logoUrl }), 
              ...(data.logoSource !== undefined && { logoSource: data.logoSource }),
              ...(data.logoFetchedAt !== undefined && { logoFetchedAt: data.logoFetchedAt }),
            },
          })
        )
      );

      totalUpserted += batch.length;
    }

    console.log(`‚úì Successfully upserted market cap data for ${totalUpserted} symbols in ${Math.ceil(marketData.length / batchSize)} batches`);
  }

  async clearPolygonData(): Promise<void> {
    console.log('üóëÔ∏è Clearing PolygonData...');
    const result = await prisma.polygonData.deleteMany();
    console.log(`‚úÖ Cleared ${result.count} PolygonData records`);
  }

  // FinalReport operations
  async generateFinalReport(): Promise<void> {
    console.log('üîÑ Generating FinalReport from FinhubData and PolygonData...');

    const finhubSymbols = await prisma.finhubData.findMany({
      select: { symbol: true },
      distinct: ['symbol'],
    });

    const polygonSymbols = await prisma.polygonData.findMany({
      select: { symbol: true },
      where: {
        Boolean: true
      },
    });

    const finhubSymbolSet = new Set(finhubSymbols.map(s => s.symbol));      
    const polygonSymbolSet = new Set(polygonSymbols.map(s => s.symbol));    

    const commonSymbols = Array.from(finhubSymbolSet).filter(symbol => polygonSymbolSet.has(symbol));

    console.log(`üìä Found ${commonSymbols.length} symbols in both FinhubData and PolygonData with Boolean = true (all conditions met)`);
    const todayNY = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
    const reportDateISO = new Date(`${todayNY}T00:00:00.000Z`);
    const snapshotDateISO = reportDateISO;

    for (const symbol of commonSymbols) {
      const finhubData = await prisma.finhubData.findFirst({
        where: { symbol },
        orderBy: { reportDate: 'desc' },
      });

      const polygonData = await prisma.polygonData.findUnique({
        where: { symbol },
      });

      if (finhubData && polygonData) {
        const epsSurp = (finhubData.epsActual != null && finhubData.epsEstimate != null && finhubData.epsEstimate !== 0)
          ? ((finhubData.epsActual - finhubData.epsEstimate) / Math.abs(finhubData.epsEstimate)) * 100
          : null;

        const revSurp = (finhubData.revenueActual != null && finhubData.revenueEstimate != null && finhubData.revenueEstimate !== 0n)
          ? new Decimal(finhubData.revenueActual.toString()).minus(finhubData.revenueEstimate.toString()).div(new Decimal(finhubData.revenueEstimate.toString()).abs()).times(100).toNumber()
          : null;

        const priceToUse = polygonData.price ?? polygonData.previousCloseRaw;
        const roundedPrice = priceToUse != null ? Math.round(priceToUse * 100) / 100 : null;
        const roundedChange = polygonData.change !== null && polygonData.change !== undefined ? Math.round(polygonData.change * 100) / 100 : null;      
        const roundedEpsActual = finhubData.epsActual != null ? Math.round(finhubData.epsActual * 100) / 100 : null;
        const roundedEpsEst = finhubData.epsEstimate != null ? Math.round(finhubData.epsEstimate * 100) / 100 : null;
        const roundedEpsSurp = epsSurp != null ? Math.round(epsSurp * 100) / 100 : null;
        const roundedRevSurp = revSurp != null ? Math.round(revSurp * 100) / 100 : null;

        const createData = {
          symbol,
          name: polygonData.name,
          size: polygonData.size,
          marketCap: polygonData.marketCap,
          marketCapDiff: polygonData.marketCapDiff,
          price: roundedPrice,
          change: roundedChange,
          epsActual: roundedEpsActual,
          epsEst: roundedEpsEst,
          epsSurp: roundedEpsSurp,
          revActual: finhubData.revenueActual,
          revEst: finhubData.revenueEstimate,
          revSurp: roundedRevSurp,
          reportDate: reportDateISO,
          snapshotDate: snapshotDateISO,
          logoUrl: (polygonData as any).logoUrl,
          logoSource: (polygonData as any).logoSource,
          logoFetchedAt: (polygonData as any).logoFetchedAt,
        };

        const updateData = {
          name: polygonData.name,
          size: polygonData.size,
          marketCap: polygonData.marketCap,
          marketCapDiff: polygonData.marketCapDiff,
          price: roundedPrice,
          change: roundedChange,
          epsActual: roundedEpsActual,
          epsEst: roundedEpsEst,
          epsSurp: roundedEpsSurp,
          revActual: finhubData.revenueActual,
          revEst: finhubData.revenueEstimate,
          revSurp: roundedRevSurp,
          reportDate: reportDateISO,
          snapshotDate: snapshotDateISO,
          logoUrl: (polygonData as any).logoUrl,
          logoSource: (polygonData as any).logoSource,
          logoFetchedAt: (polygonData as any).logoFetchedAt,
        };

        await prisma.finalReport.upsert({
          where: { symbol },
          create: createData,
          update: updateData,
        });
      }
    }

    console.log(`‚úÖ FinalReport snapshot stored: ${commonSymbols.length} symbols`);
  }

  async getFinalReport(): Promise<any[]> {
    return await prisma.finalReport.findMany({
      orderBy: { symbol: 'asc' },
    });
  }

  async clearFinalReport(): Promise<void> {
    console.log('üóëÔ∏è Clearing FinalReport...');
    const result = await prisma.finalReport.deleteMany();
    console.log(`‚úÖ Cleared ${result.count} FinalReport records`);
  }

  async updateLogoInfo(symbol: string, logoUrl: string | null, logoSource: string | null): Promise<void> {
    await prisma.finhubData.updateMany({
      where: { symbol },
      data: {
        logoUrl,
        logoSource,
        logoFetchedAt: new Date(),
      },
    });
    console.log(`   ‚Üí Updated logo info for ${symbol}: ${logoUrl} (${logoSource})`);
  }

  async getSymbolsNeedingLogoRefresh(): Promise<string[]> {
    const symbols = await prisma.finhubData.findMany({
      where: {
        OR: [
          { logoUrl: null },
          { logoFetchedAt: null },
          {
            logoFetchedAt: {
              lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
            },
          },
        ],
      },
      select: { symbol: true },
      distinct: ['symbol'],
    });

    return symbols.map(s => s.symbol);
  }

  async updateCronStatus(jobType: string, status: 'success' | 'error' | 'running', recordsProcessed?: number, errorMessage?: string): Promise<void> {   
    await prisma.cronStatus.upsert({
      where: { jobType },
      create: {
        jobType,
        lastRunAt: new Date(),
        status,
        recordsProcessed,
        errorMessage,
      },
      update: {
        lastRunAt: new Date(),
        status,
        recordsProcessed,
        errorMessage,
      },
    });
  }

  async getLastCronRun(jobType: string): Promise<Date | null> {
    const status = await prisma.cronStatus.findUnique({
      where: { jobType },
      select: { lastRunAt: true },
    });
    return status?.lastRunAt || null;
  }

  async getAllCronStatuses(): Promise<any[]> {
    return await prisma.cronStatus.findMany({
      orderBy: { lastRunAt: 'desc' },
    });
  }

  async clearAllTables(): Promise<void> {
    console.log('üõë Clearing all database tables...');

    await prisma.finalReport.deleteMany();
    await prisma.polygonData.deleteMany();
    await prisma.finhubData.deleteMany();
    await prisma.cronStatus.deleteMany();

    console.log('‚úÖ All tables cleared successfully');
  }

  async disconnect(): Promise<void> {
    await prisma.$disconnect();
  }
}

// Singleton instance
export const db = new DatabaseManager();
